#include <ibex/codegen/emitter.hpp>
#include <ibex/ir/node.hpp>

#include <cmath>
#include <cstdint>
#include <sstream>
#include <stdexcept>
#include <string>

namespace ibex::codegen {

namespace {

auto escape_string(const std::string& s) -> std::string {
    std::string out;
    out.reserve(s.size());
    for (char c : s) {
        if (c == '"') out += "\\\"";
        else if (c == '\\') out += "\\\\";
        else if (c == '\n') out += "\\n";
        else if (c == '\r') out += "\\r";
        else if (c == '\t') out += "\\t";
        else out += c;
    }
    return out;
}

auto format_double(double v) -> std::string {
    if (std::isnan(v)) return "std::numeric_limits<double>::quiet_NaN()";
    if (std::isinf(v)) return v > 0 ? "std::numeric_limits<double>::infinity()"
                                    : "-std::numeric_limits<double>::infinity()";
    // Round-trip precision
    std::ostringstream ss;
    ss.precision(17);
    ss << v;
    std::string s = ss.str();
    // Ensure it looks like a double literal (has . or e)
    if (s.find('.') == std::string::npos && s.find('e') == std::string::npos) {
        s += ".0";
    }
    return s;
}

}  // namespace

//─── Public ──────────────────────────────────────────────────────────────────

void Emitter::emit(std::ostream& out, const ir::Node& root, const Config& config) {
    out_ = &out;
    tmp_counter_ = 0;

    // Preamble
    if (!config.source_name.empty()) {
        out << "// Generated by ibex compiler\n";
        out << "// Source: " << config.source_name << "\n";
        out << "\n";
    } else {
        out << "// Generated by ibex compiler\n\n";
    }

    out << "#include <cstdint>\n";
    out << "#include <iostream>\n";
    out << "#include <limits>\n";
    out << "#include <string>\n";
    out << "#include <vector>\n";
    out << "#include <ibex/runtime/ops.hpp>\n";

    for (const auto& hdr : config.extern_headers) {
        out << "#include \"" << escape_string(hdr) << "\"\n";
    }

    out << "\n";
    out << "int main() {\n";

    auto result_var = emit_node(root);

    out << "    ibex::ops::print(" << result_var << ");\n";
    out << "    return 0;\n";
    out << "}\n";

    out_ = nullptr;
}

//─── Private helpers ─────────────────────────────────────────────────────────

auto Emitter::fresh_var() -> std::string {
    return "t" + std::to_string(tmp_counter_++);
}

auto Emitter::emit_node(const ir::Node& node) -> std::string {
    // NOLINTBEGIN cppcoreguidelines-pro-type-static-cast-downcast
    switch (node.kind()) {
        case ir::NodeKind::Scan: {
            const auto& scan = static_cast<const ir::ScanNode&>(node);
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::scan(\""
                  << escape_string(scan.source_name()) << "\");\n";
            return var;
        }

        case ir::NodeKind::Filter: {
            const auto& filter = static_cast<const ir::FilterNode&>(node);
            auto child = emit_node(*filter.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::filter(" << child
                  << ", " << emit_predicate(filter.predicate()) << ");\n";
            return var;
        }

        case ir::NodeKind::Project: {
            const auto& proj = static_cast<const ir::ProjectNode&>(node);
            auto child = emit_node(*proj.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::project(" << child << ", {";
            bool first = true;
            for (const auto& col : proj.columns()) {
                if (!first) *out_ << ", ";
                first = false;
                *out_ << '"' << escape_string(col.name) << '"';
            }
            *out_ << "});\n";
            return var;
        }

        case ir::NodeKind::Aggregate: {
            const auto& agg = static_cast<const ir::AggregateNode&>(node);
            auto child = emit_node(*agg.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::aggregate(" << child << ",\n";

            // group_by
            *out_ << "        {";
            bool first = true;
            for (const auto& g : agg.group_by()) {
                if (!first) *out_ << ", ";
                first = false;
                *out_ << '"' << escape_string(g.name) << '"';
            }
            *out_ << "},\n";

            // aggregations
            *out_ << "        {";
            first = true;
            for (const auto& a : agg.aggregations()) {
                if (!first) *out_ << ", ";
                first = false;
                *out_ << "ibex::ops::make_agg("
                      << "ibex::ir::AggFunc::" << emit_agg_func(a.func)
                      << ", \"" << escape_string(a.column.name)
                      << "\", \"" << escape_string(a.alias) << "\")";
            }
            *out_ << "});\n";
            return var;
        }

        case ir::NodeKind::Update: {
            const auto& upd = static_cast<const ir::UpdateNode&>(node);
            auto child = emit_node(*upd.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::update(" << child << ", {\n";
            bool first = true;
            for (const auto& f : upd.fields()) {
                if (!first) *out_ << ",\n";
                first = false;
                *out_ << "        ibex::ops::make_field(\"" << escape_string(f.alias)
                      << "\", " << emit_expr(f.expr) << ")";
            }
            *out_ << "\n    });\n";
            return var;
        }

        case ir::NodeKind::Window:
            throw std::runtime_error(
                "ibex_compile: WindowNode emission is not yet supported");
    }
    // NOLINTEND cppcoreguidelines-pro-type-static-cast-downcast
    throw std::runtime_error("ibex_compile: unknown IR node kind");
}

auto Emitter::emit_predicate(const ir::FilterPredicate& pred) -> std::string {
    std::string s = "ibex::ir::FilterPredicate{ibex::ir::ColumnRef{\"";
    s += escape_string(pred.column.name);
    s += "\"}, ibex::ir::CompareOp::";
    s += emit_compare_op(pred.op);
    s += ", ";

    std::visit(
        [&](const auto& v) {
            using T = std::decay_t<decltype(v)>;
            if constexpr (std::is_same_v<T, std::int64_t>) {
                s += "std::int64_t{" + std::to_string(v) + "}";
            } else if constexpr (std::is_same_v<T, double>) {
                s += format_double(v);
            } else {
                s += "std::string{\"" + escape_string(v) + "\"}";
            }
        },
        pred.value);

    s += "}";
    return s;
}

auto Emitter::emit_expr(const ir::Expr& expr) -> std::string {
    return std::visit(
        [&](const auto& node) -> std::string {
            using T = std::decay_t<decltype(node)>;
            if constexpr (std::is_same_v<T, ir::ColumnRef>) {
                return "ibex::ops::col_ref(\"" + escape_string(node.name) + "\")";
            } else if constexpr (std::is_same_v<T, ir::Literal>) {
                return std::visit(
                    [&](const auto& v) -> std::string {
                        using V = std::decay_t<decltype(v)>;
                        if constexpr (std::is_same_v<V, std::int64_t>) {
                            return "ibex::ops::int_lit(std::int64_t{" +
                                   std::to_string(v) + "})";
                        } else if constexpr (std::is_same_v<V, double>) {
                            return "ibex::ops::dbl_lit(" + format_double(v) + ")";
                        } else {
                            return "ibex::ops::str_lit(\"" + escape_string(v) + "\")";
                        }
                    },
                    node.value);
            } else if constexpr (std::is_same_v<T, ir::BinaryExpr>) {
                return "ibex::ops::binop(ibex::ir::ArithmeticOp::" +
                       emit_arith_op(node.op) + ", " +
                       emit_expr(*node.left) + ", " +
                       emit_expr(*node.right) + ")";
            } else if constexpr (std::is_same_v<T, ir::CallExpr>) {
                std::string s =
                    "ibex::ops::fn_call(\"" + escape_string(node.callee) + "\", {";
                bool first = true;
                for (const auto& arg : node.args) {
                    if (!first) s += ", ";
                    first = false;
                    s += emit_expr(*arg);
                }
                s += "})";
                return s;
            }
            throw std::runtime_error("ibex_compile: unknown expression type");
        },
        expr.node);
}

auto Emitter::emit_compare_op(ir::CompareOp op) -> std::string {
    switch (op) {
        case ir::CompareOp::Eq: return "Eq";
        case ir::CompareOp::Ne: return "Ne";
        case ir::CompareOp::Lt: return "Lt";
        case ir::CompareOp::Le: return "Le";
        case ir::CompareOp::Gt: return "Gt";
        case ir::CompareOp::Ge: return "Ge";
    }
    return "Eq";
}

auto Emitter::emit_arith_op(ir::ArithmeticOp op) -> std::string {
    switch (op) {
        case ir::ArithmeticOp::Add: return "Add";
        case ir::ArithmeticOp::Sub: return "Sub";
        case ir::ArithmeticOp::Mul: return "Mul";
        case ir::ArithmeticOp::Div: return "Div";
        case ir::ArithmeticOp::Mod: return "Mod";
    }
    return "Add";
}

auto Emitter::emit_agg_func(ir::AggFunc func) -> std::string {
    switch (func) {
        case ir::AggFunc::Sum:   return "Sum";
        case ir::AggFunc::Mean:  return "Mean";
        case ir::AggFunc::Min:   return "Min";
        case ir::AggFunc::Max:   return "Max";
        case ir::AggFunc::Count: return "Count";
        case ir::AggFunc::First: return "First";
        case ir::AggFunc::Last:  return "Last";
    }
    return "Sum";
}

}  // namespace ibex::codegen
