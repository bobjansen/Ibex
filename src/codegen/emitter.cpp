#include <ibex/codegen/emitter.hpp>
#include <ibex/ir/node.hpp>

#include <cmath>
#include <cstdint>
#include <sstream>
#include <stdexcept>
#include <string>

namespace ibex::codegen {

namespace {

auto escape_string(const std::string& s) -> std::string {
    std::string out;
    out.reserve(s.size());
    for (char c : s) {
        if (c == '"')
            out += "\\\"";
        else if (c == '\\')
            out += "\\\\";
        else if (c == '\n')
            out += "\\n";
        else if (c == '\r')
            out += "\\r";
        else if (c == '\t')
            out += "\\t";
        else
            out += c;
    }
    return out;
}

auto format_double(double v) -> std::string {
    if (std::isnan(v))
        return "std::numeric_limits<double>::quiet_NaN()";
    if (std::isinf(v))
        return v > 0 ? "std::numeric_limits<double>::infinity()"
                     : "-std::numeric_limits<double>::infinity()";
    // Round-trip precision
    std::ostringstream ss;
    ss.precision(17);
    ss << v;
    std::string s = ss.str();
    // Ensure it looks like a double literal (has . or e)
    if (s.find('.') == std::string::npos && s.find('e') == std::string::npos) {
        s += ".0";
    }
    return s;
}

}  // namespace

// ─── Public ──────────────────────────────────────────────────────────────────

auto Emitter::indent_code(const std::string& code, size_t spaces) -> std::string {
    if (spaces <= 0 || code.empty())
        return code;
    std::string prefix(spaces, ' ');
    std::string result;
    result.reserve(code.size() + (prefix.size() * 16));
    bool at_start = true;
    for (char c : code) {
        if (at_start && c != '\n') {
            result += prefix;
            at_start = false;
        }
        result += c;
        if (c == '\n')
            at_start = true;
    }
    return result;
}

void Emitter::emit(std::ostream& out, const ir::Node& root, const Config& config) {
    out_ = &out;
    tmp_counter_ = 0;
    cached_vars_.clear();

    // Preamble
    if (!config.source_name.empty()) {
        out << "// Generated by ibex compiler\n";
        out << "// Source: " << config.source_name << "\n";
        out << "\n";
    } else {
        out << "// Generated by ibex compiler\n\n";
    }

    out << "#include <cstdint>\n";
    if (config.bench_mode)
        out << "#include <chrono>\n#include <cstdio>\n";
    else
        out << "#include <iostream>\n";
    out << "#include <limits>\n";
    out << "#include <string>\n";
    out << "#include <vector>\n";
    out << "#include <ibex/runtime/ops.hpp>\n";

    for (const auto& hdr : config.extern_headers) {
        out << "#include \"" << escape_string(hdr) << "\"\n";
    }

    out << "\n";
    out << "int main() {\n";

    if (config.bench_mode) {
        // Phase 1: emit ExternCall (data loading) nodes into main buffer (setup).
        collect_extern_calls(root);

        // Phase 2: emit the query into a temporary buffer.
        std::ostringstream query_buf;
        auto* saved_out = out_;
        out_ = &query_buf;
        auto result_var = emit_node(root);
        out_ = saved_out;

        // Re-indent query code by 4 extra spaces so it sits inside the loop body.
        std::string query_code = indent_code(query_buf.str(), 4);

        // Warmup loop
        out << "\n    // Warmup\n";
        out << "    for (int _bench_w = 0; _bench_w < " << config.bench_warmup
            << "; ++_bench_w) {\n";
        out << query_code;
        out << "        (void)" << result_var << ";\n";
        out << "    }\n";

        // Timed loop
        out << "\n    // Timed iterations\n";
        out << "    auto _bench_t0 = std::chrono::steady_clock::now();\n";
        out << "    for (int _bench_i = 0; _bench_i < " << config.bench_iters
            << "; ++_bench_i) {\n";
        out << query_code;
        out << "        (void)" << result_var << ";\n";
        out << "    }\n";
        out << "    auto _bench_t1 = std::chrono::steady_clock::now();\n";
        out << "    double _avg_ms = std::chrono::duration<double, std::milli>"
               "(_bench_t1 - _bench_t0).count() / "
            << config.bench_iters << ";\n";
        out << "    std::fprintf(stderr, \"avg_ms=%.3f\\n\", _avg_ms);\n";
    } else {
        auto result_var = emit_node(root);
        if (config.print_result) {
            out << "    ibex::ops::print(" << result_var << ");\n";
        }
    }

    out << "    return 0;\n";
    out << "}\n";

    out_ = nullptr;
}

void Emitter::collect_extern_calls(const ir::Node& node) {
    if (cached_vars_.contains(&node))
        return;
    if (node.kind() == ir::NodeKind::ExternCall) {
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-static-cast-downcast)
        const auto& ec = static_cast<const ir::ExternCallNode&>(node);
        auto var = fresh_var();
        *out_ << "    auto " << var << " = " << ec.callee() << "(";
        bool first = true;
        for (const auto& arg : ec.args()) {
            if (!first)
                *out_ << ", ";
            first = false;
            *out_ << emit_raw_expr(arg);
        }
        *out_ << ");\n";
        cached_vars_[&node] = var;
        return;
    }
    for (const auto& child : node.children()) {
        collect_extern_calls(*child);
    }
}

// ─── Private helpers ─────────────────────────────────────────────────────────

auto Emitter::fresh_var() -> std::string {
    return "t" + std::to_string(tmp_counter_++);
}

auto Emitter::emit_node(const ir::Node& node) -> std::string {
    // NOLINTBEGIN cppcoreguidelines-pro-type-static-cast-downcast
    switch (node.kind()) {
        case ir::NodeKind::Scan:
            throw std::runtime_error(
                "ibex_compile: ScanNode cannot be emitted — use 'extern fn' to declare data "
                "sources");

        case ir::NodeKind::Filter: {
            const auto& filter = static_cast<const ir::FilterNode&>(node);
            auto child = emit_node(*filter.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::filter(" << child << ", "
                  << emit_predicate(filter.predicate()) << ");\n";
            return var;
        }

        case ir::NodeKind::Project: {
            const auto& proj = static_cast<const ir::ProjectNode&>(node);
            auto child = emit_node(*proj.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::project(" << child << ", {";
            bool first = true;
            for (const auto& col : proj.columns()) {
                if (!first)
                    *out_ << ", ";
                first = false;
                *out_ << '"' << escape_string(col.name) << '"';
            }
            *out_ << "});\n";
            return var;
        }

        case ir::NodeKind::Distinct: {
            auto child = emit_node(*node.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::distinct(" << child << ");\n";
            return var;
        }

        case ir::NodeKind::Order: {
            const auto& order = static_cast<const ir::OrderNode&>(node);
            auto child = emit_node(*order.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::order(" << child << ", {";
            bool first = true;
            for (const auto& key : order.keys()) {
                if (!first)
                    *out_ << ", ";
                first = false;
                *out_ << "ibex::ir::OrderKey{\"" << escape_string(key.name) << "\", "
                      << (key.ascending ? "true" : "false") << "}";
            }
            *out_ << "});\n";
            return var;
        }

        case ir::NodeKind::Aggregate: {
            const auto& agg = static_cast<const ir::AggregateNode&>(node);
            auto child = emit_node(*agg.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::aggregate(" << child << ",\n";

            // group_by
            *out_ << "        {";
            bool first = true;
            for (const auto& g : agg.group_by()) {
                if (!first)
                    *out_ << ", ";
                first = false;
                *out_ << '"' << escape_string(g.name) << '"';
            }
            *out_ << "},\n";

            // aggregations
            *out_ << "        {";
            first = true;
            for (const auto& a : agg.aggregations()) {
                if (!first)
                    *out_ << ", ";
                first = false;
                *out_ << "ibex::ops::make_agg("
                      << "ibex::ir::AggFunc::" << emit_agg_func(a.func) << ", \""
                      << escape_string(a.column.name) << "\", \"" << escape_string(a.alias)
                      << "\")";
            }
            *out_ << "});\n";
            return var;
        }

        case ir::NodeKind::Update: {
            const auto& upd = static_cast<const ir::UpdateNode&>(node);
            auto child = emit_node(*upd.children().front());
            auto var = fresh_var();
            *out_ << "    auto " << var << " = ibex::ops::update(" << child << ", {\n";
            bool first = true;
            for (const auto& f : upd.fields()) {
                if (!first)
                    *out_ << ",\n";
                first = false;
                *out_ << "        ibex::ops::make_field(\"" << escape_string(f.alias) << "\", "
                      << emit_expr(f.expr) << ")";
            }
            *out_ << "\n    });\n";
            return var;
        }

        case ir::NodeKind::Window:
            throw std::runtime_error("ibex_compile: WindowNode emission is not yet supported");

        case ir::NodeKind::ExternCall: {
            // In bench mode ExternCall nodes were pre-emitted; reuse the var.
            if (auto it = cached_vars_.find(&node); it != cached_vars_.end())
                return it->second;
            const auto& ec = static_cast<const ir::ExternCallNode&>(node);
            auto var = fresh_var();
            *out_ << "    auto " << var << " = " << ec.callee() << "(";
            bool first = true;
            for (const auto& arg : ec.args()) {
                if (!first)
                    *out_ << ", ";
                first = false;
                *out_ << emit_raw_expr(arg);
            }
            *out_ << ");\n";
            return var;
        }

        case ir::NodeKind::Join: {
            const auto& join = static_cast<const ir::JoinNode&>(node);
            if (join.children().size() != 2) {
                throw std::runtime_error("ibex_compile: JoinNode expects two children");
            }
            auto left = emit_node(*join.children()[0]);
            auto right = emit_node(*join.children()[1]);
            auto var = fresh_var();
            const char* fn = nullptr;
            switch (join.kind()) {
                case ir::JoinKind::Inner:
                    fn = "inner_join";
                    break;
                case ir::JoinKind::Left:
                    fn = "left_join";
                    break;
                case ir::JoinKind::Asof:
                    throw std::runtime_error(
                        "ibex_compile: asof join emission is not yet supported");
            }
            *out_ << "    auto " << var << " = ibex::ops::" << fn << "(" << left << ", " << right
                  << ", {";
            bool first = true;
            for (const auto& key : join.keys()) {
                if (!first)
                    *out_ << ", ";
                first = false;
                *out_ << '"' << escape_string(key) << '"';
            }
            *out_ << "});\n";
            return var;
        }
    }
    // NOLINTEND cppcoreguidelines-pro-type-static-cast-downcast
    throw std::runtime_error("ibex_compile: unknown IR node kind");
}

auto Emitter::emit_predicate(const ir::FilterPredicate& pred) -> std::string {
    std::string s = "ibex::ir::FilterPredicate{ibex::ir::ColumnRef{\"";
    s += escape_string(pred.column.name);
    s += "\"}, ibex::ir::CompareOp::";
    s += emit_compare_op(pred.op);
    s += ", ";

    std::visit(
        [&](const auto& v) {
            using T = std::decay_t<decltype(v)>;
            if constexpr (std::is_same_v<T, std::int64_t>) {
                s += "std::int64_t{" + std::to_string(v) + "}";
            } else if constexpr (std::is_same_v<T, double>) {
                s += format_double(v);
            } else if constexpr (std::is_same_v<T, std::string>) {
                s += "std::string{\"" + escape_string(v) + "\"}";
            } else {
                // ScalarRef: a named scalar variable — emit as a runtime lookup
                s += "ibex::ir::FilterPredicate::ScalarRef{\"" + escape_string(v.name) + "\"}";
            }
        },
        pred.value);

    s += "}";
    return s;
}

auto Emitter::emit_expr(const ir::Expr& expr) -> std::string {
    return std::visit(
        [&](const auto& node) -> std::string {
            using T = std::decay_t<decltype(node)>;
            if constexpr (std::is_same_v<T, ir::ColumnRef>) {
                return "ibex::ops::col_ref(\"" + escape_string(node.name) + "\")";
            } else if constexpr (std::is_same_v<T, ir::Literal>) {
                return std::visit(
                    [&](const auto& v) -> std::string {
                        using V = std::decay_t<decltype(v)>;
                        if constexpr (std::is_same_v<V, std::int64_t>) {
                            return "ibex::ops::int_lit(std::int64_t{" + std::to_string(v) + "})";
                        } else if constexpr (std::is_same_v<V, double>) {
                            return "ibex::ops::dbl_lit(" + format_double(v) + ")";
                        } else {
                            return "ibex::ops::str_lit(\"" + escape_string(v) + "\")";
                        }
                    },
                    node.value);
            } else if constexpr (std::is_same_v<T, ir::BinaryExpr>) {
                return "ibex::ops::binop(ibex::ir::ArithmeticOp::" + emit_arith_op(node.op) + ", " +
                       emit_expr(*node.left) + ", " + emit_expr(*node.right) + ")";
            } else if constexpr (std::is_same_v<T, ir::CallExpr>) {
                std::string s = "ibex::ops::fn_call(\"" + escape_string(node.callee) + "\", {";
                bool first = true;
                for (const auto& arg : node.args) {
                    if (!first)
                        s += ", ";
                    first = false;
                    s += emit_expr(*arg);
                }
                s += "})";
                return s;
            }
            throw std::runtime_error("ibex_compile: unknown expression type");
        },
        expr.node);
}

auto Emitter::emit_compare_op(ir::CompareOp op) -> std::string {
    switch (op) {
        case ir::CompareOp::Eq:
            return "Eq";
        case ir::CompareOp::Ne:
            return "Ne";
        case ir::CompareOp::Lt:
            return "Lt";
        case ir::CompareOp::Le:
            return "Le";
        case ir::CompareOp::Gt:
            return "Gt";
        case ir::CompareOp::Ge:
            return "Ge";
    }
    return "Eq";
}

auto Emitter::emit_arith_op(ir::ArithmeticOp op) -> std::string {
    switch (op) {
        case ir::ArithmeticOp::Add:
            return "Add";
        case ir::ArithmeticOp::Sub:
            return "Sub";
        case ir::ArithmeticOp::Mul:
            return "Mul";
        case ir::ArithmeticOp::Div:
            return "Div";
        case ir::ArithmeticOp::Mod:
            return "Mod";
    }
    return "Add";
}

auto Emitter::emit_raw_expr(const ir::Expr& expr) -> std::string {
    return std::visit(
        [&](const auto& node) -> std::string {
            using T = std::decay_t<decltype(node)>;
            if constexpr (std::is_same_v<T, ir::Literal>) {
                return std::visit(
                    [&](const auto& v) -> std::string {
                        using V = std::decay_t<decltype(v)>;
                        if constexpr (std::is_same_v<V, std::int64_t>) {
                            return std::to_string(v);
                        } else if constexpr (std::is_same_v<V, double>) {
                            return format_double(v);
                        } else {
                            return "\"" + escape_string(v) + "\"";
                        }
                    },
                    node.value);
            }
            throw std::runtime_error("ibex_compile: non-literal argument in extern call");
        },
        expr.node);
}

auto Emitter::emit_agg_func(ir::AggFunc func) -> std::string {
    switch (func) {
        case ir::AggFunc::Sum:
            return "Sum";
        case ir::AggFunc::Mean:
            return "Mean";
        case ir::AggFunc::Min:
            return "Min";
        case ir::AggFunc::Max:
            return "Max";
        case ir::AggFunc::Count:
            return "Count";
        case ir::AggFunc::First:
            return "First";
        case ir::AggFunc::Last:
            return "Last";
    }
    return "Sum";
}

}  // namespace ibex::codegen
